# Story 2.1: Dynamic Agent System Optimization

## User Story
**As an n8n User**, I want the dynamic 3-tier agent system optimized for speed and efficiency so that agent handovers are instant and memory usage stays minimal.

## Context & Problem
The dynamic agent system is the **core differentiator** - it needs to be fast and lean:

- **7 different agent classes** with overlapping code (could be 4-5)
- **3 separate tool registries** causing lookup delays
- **No memory cleanup** in agent lifecycles
- **140+ test files** many testing the same things

This is about making the agents **lightning fast**, not adding enterprise features.

## Acceptance Criteria

### ðŸŽ¯ Success Metrics
- [ ] **Agent Classes**: Reduce from 7 to 4-5 optimized classes
- [ ] **Tool Registry**: Single fast registry (<50ms lookups)
- [ ] **Memory Usage**: 30% reduction through proper cleanup
- [ ] **Test Suite**: 50% faster execution (remove duplicates)

## Technical Implementation

### Step 1: Consolidate Agent Classes (2 hours)

#### Current Bloat:
```typescript
// We have these overlapping implementations:
WorkflowArchitect, DeveloperSpecialist, IntegrationSpecialist,
NodeSpecialist, PerformanceSpecialist, JavaScriptSpecialist, 
GuidanceSpecialist
```

#### Optimized Structure:
```typescript
// Tier 1: Master Orchestrator
export class Orchestrator extends BaseAgent {
  async route(context: AgentContext): Promise<AgentResult> {
    // Smart routing logic
  }
}

// Tier 2: Core Specialists (combine overlapping ones)
export class BuilderAgent extends BaseAgent {} // Combines Developer + Performance
export class ConnectorAgent extends BaseAgent {} // Stays as is
export class NodeExpertAgent extends BaseAgent {} // Combines Node + Integration  
export class ScriptGuardAgent extends BaseAgent {} // Combines JavaScript validation

// Tier 3: Support
export class GuideAgent extends BaseAgent {} // Documentation help
```

### Step 2: Unify Tool Registry (1 hour)

```typescript
// Single, fast registry
export class UnifiedToolRegistry {
  private tools = new Map<string, Tool>();
  private cache = new Map<string, CachedResult>();
  
  register(tool: Tool): void {
    this.tools.set(tool.name, tool);
  }
  
  lookup(name: string): Tool | undefined {
    // Check cache first (sub-millisecond)
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    return this.tools.get(name);
  }
}
```

### Step 3: Add Memory Cleanup (1 hour)

```typescript
export abstract class BaseAgent {
  private resources: Set<() => void> = new Set();
  
  // Track resources
  protected trackResource(cleanup: () => void): void {
    this.resources.add(cleanup);
  }
  
  // Clean up when done
  async cleanup(): Promise<void> {
    for (const cleanup of this.resources) {
      cleanup();
    }
    this.resources.clear();
  }
}
```

### Step 4: Streamline Tests (2 hours)

```bash
# Find duplicate tests
grep -r "describe\|test\|it" src/tests/ | sort | uniq -d

# Remove redundant test files
# Keep only:
# - One test per agent class
# - One integration test for handovers  
# - One performance test for registry
# Total: ~20 focused test files (from 140+)
```

## Definition of Done

### âœ… Checklist
- [ ] 4-5 clean agent classes
- [ ] Single unified registry
- [ ] Memory cleanup in all agents
- [ ] Test suite runs in <30 seconds

## Quick Validation
```bash
# Agent system still works
npm run test:agents

# Memory doesn't grow
node --expose-gc scripts/memory-test.js

# Registry is fast
npm run benchmark:registry
```

## Result
**Before**: 7 classes, 3 registries, 140 tests, memory leaks  
**After**: 5 classes, 1 registry, 20 tests, clean memory

## Story Points: 5
**Estimated Effort**: 6 hours (1 day)
**Priority**: Critical for lightweight performance